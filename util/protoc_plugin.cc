// #include <string>
// #include <cctype>

// #pragma GCC diagnostic push
// #pragma GCC diagnostic ignored "-Wunused-parameter"

// #include <google/protobuf/io/printer.h>
// #include <google/protobuf/compiler/plugin.h>
// #include <google/protobuf/descriptor.h>
// #include <google/protobuf/io/zero_copy_stream.h>
// #include <google/protobuf/compiler/code_generator.h>

// #pragma GCC diagnostic pop

// using namespace google::protobuf;
// using namespace google::protobuf::io;

// class ProtocPlugin : public google::protobuf::compiler::CodeGenerator {
// public:
//     bool Generate(const google::protobuf::FileDescriptor* file,
//                   const std::string& parameter,
//                   google::protobuf::compiler::GeneratorContext* context,
//                   std::string* error) const override;
// };

// static std::string StripProto(const std::string& filename) {
//     if (filename.length() > 6 && filename.substr(filename.length() - 6) == ".proto") {
//         return filename.substr(0, filename.length() - 6);
//     }
//     return filename;
// }

// static std::string FullNameToCpp(const std::string& full_name) {
//     std::string result = full_name;
//     for (char& c : result) {
//         if (c == '.') c = ':';
//     }
//     return "::" + result;
// }

// bool ProtocPlugin::Generate(
//     const FileDescriptor* file,
//     const std::string& /*parameter*/,
//     compiler::GeneratorContext* context,
//     std::string* /*error*/) const {

//     if (file->service_count() == 0) return true;

//     std::string header_name = StripProto(file->name()) + ".service.h";
//     std::unique_ptr<ZeroCopyOutputStream> output(context->Open(header_name));
//     Printer printer(output.get(), '$');

//     printer.Print("// Generated by the protocol buffer compiler.  DO NOT EDIT!\n");
//     printer.Print("// source: $source$\n\n", "source", file->name());
//     printer.Print("#pragma once\n\n");

//     // Includes
//     printer.Print("#include \"$pb_header$\"\n", "pb_header", StripProto(file->name()) + ".pb.h");
//     printer.Print("#include \"client/client_channel.h\"\n\n");
//     printer.Print("#include <memory>\n");
//     printer.Print("#include <string>\n\n");

//     // Namespace
//     std::string ns = file->package();
//     if (!ns.empty()) {
//         printer.Print("namespace $ns$ {\n\n", "ns", ns);
//     }

//     // For each service
//     for (int i = 0; i < file->service_count(); ++i) {
//         const ServiceDescriptor* service = file->service(i);
//         std::string service_name = service->name();
//         std::string full_service_name = service->full_name();

//         // --- 1. Client Stub ---
//         printer.Print("// Client Stub for $service_name$\n", "service_name", service_name);
//         printer.Print("class $service_name$Stub {\n", "service_name", service_name);
//         printer.Print("public:\n");
//         printer.Indent();
//         printer.Print("explicit $service_name$Stub(xuanqiong::ClientChannel* channel)\n"
//                       "    : channel_(channel) {}\n\n",
//                       "service_name", service_name);

//         for (int j = 0; j < service->method_count(); ++j) {
//             const MethodDescriptor* method = service->method(j);
//             std::string method_name = method->name();
//             std::string input_type = FullNameToCpp(method->input_type()->full_name());
//             std::string output_type = FullNameToCpp(method->output_type()->full_name());
//             std::string full_method_name = full_service_name + "." + method_name;

//             printer.Print("void $method_name$(const $input_type$* request, $output_type$* response) {\n",
//                           "output_type", output_type,
//                           "method_name", method_name,
//                           "input_type", input_type);
//             printer.Indent();
//             printer.Print("channel_->call_method(request, response, \"$service_name$\", $method_id$);\n",
//                           "service_name", service_name,
//                           "method_id", std::to_string(j));
//             printer.Outdent();
//             printer.Print("}\n");
//         }

//         printer.Outdent();
//         printer.Print("\nprivate:\n");
//         printer.Indent();
//         printer.Print("xuanqiong::ClientChannel* channel_;\n");
//         printer.Outdent();
//         printer.Print("};\n\n");

//         // --- 2. Server Interface ---
//         printer.Print("// Service Interface for $service_name$\n", "service_name", service_name);
//         printer.Print("class $service_name$Interface {\n", "service_name", service_name);
//         printer.Print("public:\n");
//         printer.Indent();
//         printer.Print("virtual ~$service_name$Interface() = default;\n\n",
//                       "service_name", service_name);

//         for (int j = 0; j < service->method_count(); ++j) {
//             const MethodDescriptor* method = service->method(j);
//             std::string method_name = method->name();
//             std::string input_type = FullNameToCpp(method->input_type()->full_name());
//             std::string output_type = FullNameToCpp(method->output_type()->full_name());

//             printer.Print("virtual void $method_name$(const $input_type$* request, $output_type$* response) = 0;\n",
//                           "output_type", output_type,
//                           "method_name", method_name,
//                           "input_type", input_type);
//         }
        
//         // new request
//         printer.Print("\n");
//         printer.Print("// Create a new request message for the given method_id.\n");
//         printer.Print("google::protobuf::Message* new_request(int method_id) {\n");
//         printer.Indent();
//         printer.Print("switch (method_id) {\n");
//         printer.Indent();
//         for (int j = 0; j < service->method_count(); ++j) {
//             const MethodDescriptor* method = service->method(j);
//             std::string method_name = method->name();
//             std::string input_type = FullNameToCpp(method->input_type()->full_name());

//             printer.Print("case $method_id$:\n", "method_id", std::to_string(j));
//             printer.Indent();
//             printer.Print("return new $input_type$;\n", "input_type", input_type);
//             printer.Outdent();
//         }
//         printer.Print("default:\n");
//         printer.Indent();
//         printer.Print("throw std::runtime_error(\"Unknown method_id\");\n");
//         printer.Outdent();
//         printer.Outdent();
//         printer.Print("}\n");
//         printer.Outdent();
//         printer.Print("}\n");

//         // new response
//         printer.Print("\n");
//         printer.Print("// Create a new response message for the given method_id.\n");
//         printer.Print("google::protobuf::Message* new_response(int method_id) {\n");
//         printer.Indent();
//         printer.Print("switch (method_id) {\n");
//         printer.Indent();
//         for (int j = 0; j < service->method_count(); ++j) {
//             const MethodDescriptor* method = service->method(j);
//             std::string method_name = method->name();
//             std::string output_type = FullNameToCpp(method->output_type()->full_name());

//             printer.Print("case $method_id$:\n", "method_id", std::to_string(j));
//             printer.Indent();
//             printer.Print("return new $output_type$;\n", "output_type", output_type);
//             printer.Outdent();
//         }
//         printer.Print("default:\n");
//         printer.Indent();
//         printer.Print("throw std::runtime_error(\"Unknown method_id\");\n");
//         printer.Outdent();
//         printer.Outdent();
//         printer.Print("}\n");
//         printer.Outdent();
//         printer.Print("}\n");

//         // call_method helper
//         printer.Print("\n");
//         printer.Print("// Call the method with the given method_id.\n");
//         printer.Print("void call_method(\n");
//         printer.Print("  const google::protobuf::Message* request,\n");
//         printer.Print("  google::protobuf::Message* response,\n");
//         printer.Print("  int method_id\n");
//         printer.Print(") {\n");
//         printer.Indent();
//         printer.Print("switch (method_id) {\n");
//         printer.Indent();
//         for (int j = 0; j < service->method_count(); ++j) {
//             const MethodDescriptor* method = service->method(j);
//             std::string method_name = method->name();
//             std::string input_type = FullNameToCpp(method->input_type()->full_name());
//             std::string output_type = FullNameToCpp(method->output_type()->full_name());

//             printer.Print("case $method_id$:\n", "method_id", std::to_string(j));
//             printer.Indent();
//             printer.Print("$method_name$(\n", "method_name", method_name);
//             printer.Indent();
//             printer.Print("static_cast<const $input_type$*>(request),\n", "input_type", input_type);
//             printer.Print("static_cast<$output_type$*>(response)\n", "output_type", output_type);
//             printer.Outdent();
//             printer.Print(");\n");
//             printer.Outdent();
//         }
//         printer.Print("default:\n");
//         printer.Indent();
//         printer.Print("throw std::runtime_error(\"Unknown method_id\");\n");
//         printer.Outdent();
//         printer.Outdent();
//         printer.Print("}\n");
//         printer.Outdent();
//         printer.Print("}\n\n");
//         printer.Outdent();
//         printer.Print("};\n");

//         // --- 3. 默认服务实现（可选，用于注册）---
//     //     printer.Print("// Default implementation that throws\n");
//     //     printer.Print("class $service_name$ServiceImpl : public $service_name$ServiceInterface {\n",
//     //                   "service_name", service_name);
//     //     printer.Print("public:\n");
//     //     printer.Indent();
//     //     for (int j = 0; j < service->method_count(); ++j) {
//     //         const MethodDescriptor* method = service->method(j);
//     //         std::string method_name = method->name();
//     //         std::string input_type = FullNameToCpp(method->input_type()->full_name());
//     //         std::string output_type = FullNameToCpp(method->output_type()->full_name());

//     //         printer.Print("$output_type$ $method_name$(const $input_type$& /*request*/) override {\n",
//     //                       "output_type", output_type,
//     //                       "method_name", method_name,
//     //                       "input_type", input_type);
//     //         printer.Indent();
//     //         printer.Print("throw std::runtime_error(\"Method $method_name$ not implemented\");\n",
//     //                       "method_name", method_name);
//     //         printer.Outdent();
//     //         printer.Print("}\n\n");
//     //     }
//     //     printer.Outdent();
//     //     printer.Print("};\n\n");

//     //     // --- 4. 服务注册辅助函数 ---
//     //     printer.Print("// Helper to register service to MyServer\n");
//     //     printer.Print("void Register$service_name$Service(MyServer* server, $service_name$ServiceInterface* service) {\n",
//     //                   "service_name", service_name);
//     //     printer.Indent();
//     //     for (int j = 0; j < service->method_count(); ++j) {
//     //         const MethodDescriptor* method = service->method(j);
//     //         std::string method_name = method->name();
//     //         std::string full_method_name = full_service_name + "." + method_name;
//     //         std::string input_type = FullNameToCpp(method->input_type()->full_name());
//     //         std::string output_type = FullNameToCpp(method->output_type()->full_name());

//     //         printer.Print("server->RegisterServiceMethod(\n");
//     //         printer.Indent();
//     //         printer.Print("\"$full_method$\",\n", "full_method", full_method_name);
//     //         printer.Print("[service] (const google::protobuf::Message& req) -> std::unique_ptr<google::protobuf::Message> {\n");
//     //         printer.Indent();
//     //         printer.Print("const auto& typed_req = static_cast<const $input_type$&>(req);\n",
//     //                       "input_type", input_type);
//     //         printer.Print("auto resp = std::make_unique<$output_type$>(service->$method_name$(typed_req));\n",
//     //                       "output_type", output_type,
//     //                       "method_name", method_name);
//     //         printer.Print("return resp;\n");
//     //         printer.Outdent();
//     //         printer.Print("});\n\n");
//     //         printer.Outdent();
//     //     }
//     //     printer.Outdent();
//     //     printer.Print("}\n\n");
//     }

//     // Close namespace
//     if (!ns.empty()) {
//         printer.Print("}  // namespace $ns$\n\n", "ns", ns);
//     }

//     return true;
// }

// int main(int argc, char* argv[]) {
//     ProtocPlugin generator;
//     return google::protobuf::compiler::PluginMain(argc, argv, &generator);
// }

#include <string>
#include <cctype>
#include <memory>

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"

#include <google/protobuf/io/printer.h>
#include <google/protobuf/compiler/plugin.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/io/zero_copy_stream.h>
#include <google/protobuf/compiler/code_generator.h>
#include <google/protobuf/service.h>
#include <google/protobuf/message.h>
#include <google/protobuf/descriptor.h>

#pragma GCC diagnostic pop

using namespace google::protobuf;
using namespace google::protobuf::io;

class ProtocPlugin : public google::protobuf::compiler::CodeGenerator {
public:
    bool Generate(const google::protobuf::FileDescriptor* file,
                  const std::string& parameter,
                  google::protobuf::compiler::GeneratorContext* context,
                  std::string* error) const override;
};

static std::string StripProto(const std::string& filename) {
    if (filename.length() > 6 && filename.substr(filename.length() - 6) == ".proto") {
        return filename.substr(0, filename.length() - 6);
    }
    return filename;
}

static std::string FullNameToCpp(const std::string& full_name) {
    std::string result = full_name;
    for (char& c : result) {
        if (c == '.') c = ':';
    }
    return "::" + result;
}

bool ProtocPlugin::Generate(
    const FileDescriptor* file,
    const std::string& /*parameter*/,
    compiler::GeneratorContext* context,
    std::string* /*error*/) const {

    if (file->service_count() == 0) return true;

    std::string header_name = StripProto(file->name()) + ".service.h";
    std::unique_ptr<ZeroCopyOutputStream> output(context->Open(header_name));
    Printer printer(output.get(), '$');

    printer.Print("// Generated by the protocol buffer compiler.  DO NOT EDIT!\n");
    printer.Print("// source: $source$\n\n", "source", file->name());
    printer.Print("#pragma once\n\n");

    // Includes
    printer.Print("#include \"$pb_header$\"\n", "pb_header", StripProto(file->name()) + ".pb.h");
    printer.Print("#include \"client/client_channel.h\"\n\n");
    printer.Print("#include <google/protobuf/service.h>\n");
    printer.Print("#include <google/protobuf/message.h>\n");
    printer.Print("#include <google/protobuf/descriptor.h>\n");
    printer.Print("#include <memory>\n");
    printer.Print("#include <string>\n");
    printer.Print("#include <stdexcept>\n\n");

    // Namespace
    std::string ns = file->package();
    if (!ns.empty()) {
        printer.Print("namespace $ns$ {\n\n", "ns", ns);
    }

    // For each service
    for (int i = 0; i < file->service_count(); ++i) {
        const ServiceDescriptor* service = file->service(i);
        std::string service_name = service->name();
        std::string full_service_name = service->full_name();
        std::string full_service_name_cpp = FullNameToCpp(full_service_name);

        // --- 1. Client Stub ---
        printer.Print("// Client Stub for $service_name$\n", "service_name", service_name);
        printer.Print("class $service_name$Stub {\n", "service_name", service_name);
        printer.Print("public:\n");
        printer.Indent();
        printer.Print("explicit $service_name$Stub(xuanqiong::ClientChannel* channel)\n"
                      "    : channel_(channel) {}\n\n",
                      "service_name", service_name);

        for (int j = 0; j < service->method_count(); ++j) {
            const MethodDescriptor* method = service->method(j);
            std::string method_name = method->name();
            std::string input_type = FullNameToCpp(method->input_type()->full_name());
            std::string output_type = FullNameToCpp(method->output_type()->full_name());

            printer.Print("void $method_name$(const $input_type$* request, $output_type$* response) {\n",
                          "output_type", output_type,
                          "method_name", method_name,
                          "input_type", input_type);
            printer.Indent();
            printer.Print("channel_->call_method(request, response, \"$service_name$\", $method_id$);\n",
                          "service_name", service_name,
                          "method_id", std::to_string(j));
            printer.Outdent();
            printer.Print("}\n");
        }

        printer.Outdent();
        printer.Print("\nprivate:\n");
        printer.Indent();
        printer.Print("xuanqiong::ClientChannel* channel_;\n");
        printer.Outdent();
        printer.Print("};\n\n");

        // --- 2. Server Service (inherits google::protobuf::Service) ---
        printer.Print("// Service implementation for $service_name$, inherits google::protobuf::Service\n",
                      "service_name", service_name);
        printer.Print("class $service_name$Service : public ::google::protobuf::Service {\n",
                      "service_name", service_name);
        printer.Print("public:\n");
        printer.Indent();
        printer.Print("virtual ~$service_name$Service() = default;\n\n",
                      "service_name", service_name);

        // Pure virtual methods for each RPC
        for (int j = 0; j < service->method_count(); ++j) {
            const MethodDescriptor* method = service->method(j);
            std::string method_name = method->name();
            std::string input_type = FullNameToCpp(method->input_type()->full_name());
            std::string output_type = FullNameToCpp(method->output_type()->full_name());

            printer.Print("virtual void $method_name$(\n",
                          "method_name", method_name);
            printer.Indent();
            printer.Print("const $input_type$* request,\n", "input_type", input_type);
            printer.Print("$output_type$* response,\n", "output_type", output_type);
            printer.Print("::google::protobuf::Closure* done\n");
            printer.Outdent();
            printer.Print(") = 0;\n\n");
        }

        // GetDescriptor
        printer.Print("const ::google::protobuf::ServiceDescriptor* GetDescriptor() override {\n");
        printer.Indent();
        printer.Print("return $full_service_name$_descriptor();\n",
                      "full_service_name", full_service_name_cpp);
        printer.Outdent();
        printer.Print("}\n\n");

        // CallMethod
        printer.Print("void CallMethod(\n");
        printer.Print("  const ::google::protobuf::MethodDescriptor* method,\n");
        printer.Print("  ::google::protobuf::RpcController* controller,\n");
        printer.Print("  const ::google::protobuf::Message* request,\n");
        printer.Print("  ::google::protobuf::Message* response,\n");
        printer.Print("  ::google::protobuf::Closure* done\n");
        printer.Print(") override {\n");
        printer.Indent();

        if (service->method_count() > 0) {
            printer.Print("static const ::google::protobuf::ServiceDescriptor* desc = $full_service_name$_descriptor();\n",
                          "full_service_name", full_service_name_cpp);
            printer.Print("(void)desc; // suppress unused warning\n\n");

            for (int j = 0; j < service->method_count(); ++j) {
                const MethodDescriptor* method_desc = service->method(j);
                std::string method_name = method_desc->name();
                std::string input_type = FullNameToCpp(method_desc->input_type()->full_name());
                std::string output_type = FullNameToCpp(method_desc->output_type()->full_name());

                printer.Print("if (method == desc->method($index$)) {\n", "index", std::to_string(j));
                printer.Indent();
                printer.Print("$method_name$(\n", "method_name", method_name);
                printer.Indent();
                printer.Print("static_cast<const $input_type$*>(request),\n", "input_type", input_type);
                printer.Print("static_cast<$output_type$*>(response),\n", "output_type", output_type);
                printer.Print("done\n");
                printer.Outdent();
                printer.Print(");\n");
                printer.Print("return;\n");
                printer.Outdent();
                printer.Print("}\n\n");
            }
        }

        // Unknown method
        printer.Print("// Unknown method\n");
        printer.Print("if (controller) {\n");
        printer.Print("  controller->SetFailed(\"Method not found.\");\n");
        printer.Print("}\n");
        printer.Print("if (done) done->Run();\n");
        printer.Outdent();
        printer.Print("}\n\n");

        // GetRequestPrototype
        printer.Print("const ::google::protobuf::Message& GetRequestPrototype(\n");
        printer.Print("  const ::google::protobuf::MethodDescriptor* method\n");
        printer.Print(") const override {\n");
        printer.Indent();
        printer.Print("return *::google::protobuf::MessageFactory::generated_factory()->GetPrototype(\n");
        printer.Print("    method->input_type());\n");
        printer.Outdent();
        printer.Print("}\n\n");

        // GetResponsePrototype
        printer.Print("const ::google::protobuf::Message& GetResponsePrototype(\n");
        printer.Print("  const ::google::protobuf::MethodDescriptor* method\n");
        printer.Print(") const override {\n");
        printer.Indent();
        printer.Print("return *::google::protobuf::MessageFactory::generated_factory()->GetPrototype(\n");
        printer.Print("    method->output_type());\n");
        printer.Outdent();
        printer.Print("}\n\n");

        printer.Outdent();
        printer.Print("};\n\n");
    }

    // Close namespace
    if (!ns.empty()) {
        printer.Print("}  // namespace $ns$\n\n", "ns", ns);
    }

    return true;
}

int main(int argc, char* argv[]) {
    ProtocPlugin generator;
    return google::protobuf::compiler::PluginMain(argc, argv, &generator);
}